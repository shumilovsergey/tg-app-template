version: '3.8'

services:
  # Backend Flask application
  backend:
    build: .
    container_name: ${PROJECT_NAME}-flask
    ports:
      - "${FLASK_PORT}:${FLASK_PORT}"
    environment:
      - PROJECT_NAME=${PROJECT_NAME}
      - FLASK_PORT=${FLASK_PORT}
      - FLASK_DEBUG=${FLASK_DEBUG}
      - SECRET_KEY=${SECRET_KEY}
      - BOT_TOKEN=${BOT_TOKEN}
      - FRONTEND_URL=${FRONTEND_URL}
      - BACKEND_URL=${BACKEND_URL}
      - SHUMILOV_WEBSITE=${SHUMILOV_WEBSITE}
      - PYTHONUNBUFFERED=${PYTHONUNBUFFERED}
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - private-network  # Flask-Redis communication
      - public-network   # Flask port exposure
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:${FLASK_PORT}/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Redis database
  redis:
    image: redis:7-alpine
    container_name: ${PROJECT_NAME}-redis
    command: redis-server --appendonly yes --appendfsync everysec --port 6379
    volumes:
      - ./redis_data:/data               # Bind mount for data safety
    networks:
      - private-network  # Only Flask can access Redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "-p", "6379", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    sysctls:
      - net.core.somaxconn=1024

networks:
  # Private network for Flask-Redis communication only
  private-network:
    driver: bridge
    name: ${PROJECT_NAME}-private-network
    internal: true  # No external access

  # Public network for Flask port exposure
  public-network:
    driver: bridge
    name: ${PROJECT_NAME}-public-network

# No volumes section needed - using bind mount for Redis data